#ifndef RAW_OLED12832_SH1306_H
#define RAW_OLED12832_SH1306_H

class RawOled12832_sh1306
{
	public:
		I2C *_i2c;
    private:
        uint8_t i2c_addr;
        I2C i2c;
		uint8_t buffer[128*32/8];
        void write_cmd(uint8_t cmd)
        {
            char buf[2];
            buf[0]=0x00;
            buf[1]=cmd;
            _i2c->write(i2c_addr,buf,2);
        }
        void write_data(uint8_t data)
        {
            char buf[2];
            buf[0]=0x40;
            buf[1]=data;
            _i2c->write(i2c_addr,buf,2);
        }
        void chip_init(void)
        {
			write_cmd(0xAE); //Display OFF (sleep mode)
			write_cmd(0xD5); //Set Display Clock Divide Ratio/Oscillator Frequency
			write_cmd(0x80); //0x71
			write_cmd(0xA8); //Set Multiplex Ratio
			write_cmd(0x1F); //32
			write_cmd(0xD3); //Set Display Offset
			write_cmd(0x00); //
			write_cmd(0x40); //Set Display Start Line
			write_cmd(0x8D); //Set Display Offset
			write_cmd(0x14); //VCC Generated by Internal DC/DC circuit
			write_cmd(0xA1); //Set Segment Re-map
			write_cmd(0xC8); //Set COM Output Scan Direction
			write_cmd(0xDA); //Set COM Pins Hardware Configuration
			write_cmd(0x02); //
			write_cmd(0x81); //Set Contrast Control
			write_cmd(0x28); //0x23
			write_cmd(0xD9); //Set Pre-charge Period
			write_cmd(0xF1); //VCC Generated by Internal DC/DC circuit
			write_cmd(0xDB); //Set VCOMH Deselect Level
			write_cmd(0x40); //0x3C
			write_cmd(0xA4); //Output follows RAM content
			write_cmd(0xA6); //Set Normal Display
        }
    public:
        RawOled12832_sh1306(PinName sda,PinName scl):i2c(sda,scl)
        {
			Width=128;
			Height=32;
			LineByteCount=128/8;

            _i2c = &i2c;
            _i2c->set_speed(I2C_SPEED_3M4);
            i2c_addr = 0x78;
            chip_init();
            clear();
            update();
            on();
        }
        void on(void)
        {
            write_cmd(0xAF); //display on
            write_cmd(0x81); //contrast control
            write_cmd(0x80);
        }
        void off(void)
        {
            //write_cmd(0xAE); //display off
            write_cmd(0x81); //contrast control
            write_cmd(0x01);
        }
    public:
        uint32_t Width;
        uint32_t Height;
        uint32_t LineByteCount;
        uint8_t DataBuffer[128*32/8];
        void clear(void)
        {
            memset(DataBuffer,0,sizeof(DataBuffer));
        }
        void update(void)
        {
            int x0=0;
            int x1=Width-1;
            int byte_y0=0;
            int byte_y1=Height/8-1;

			uint8_t *pbuffer = buffer;

            int x,byte_y;
            for(byte_y=byte_y0;byte_y<=byte_y1;byte_y++)
            {
				uint8_t *ptr = DataBuffer + byte_y*8*LineByteCount;
				for(x=x0;x<=x1;x++)
				{
					uint8_t *p = ptr;
					uint8_t c=0;
					int k;
					for(k=0;k<8;k++)
					{
						if(p[x/8]&(1<<(x%8)))c|=(1<<k);
						p+=LineByteCount;
					}
					*pbuffer++=c;
				}
            }

			pbuffer = buffer;
            for(byte_y=byte_y0;byte_y<=byte_y1;byte_y++)
            {
                write_cmd(0xB0+byte_y);  					//set page address
                write_cmd((x0+0)%16);    					//set lower column address
                write_cmd(0x10+(x0+0)/16); 			        //set higher column address
				for(x=x0;x<=x1;x++)
				{
					write_data(*pbuffer++);
				}
            }
        }
};

#endif

